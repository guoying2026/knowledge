  
假设你想发送三个HTTP请求并处理它们的合并结果。同步的方式是先发送第一个请求，等待响应，然后发送第二个请求，等待，依此类推。
  
在并行处理的世界中，我们发送请求但不等待。相反，我们立即发送下一个请求，然后再发送另一个请求。只有当所有请求都发送完毕后，我们才等待它们完成。在等待期间，我们定期检查是否有一个请求从服务器得到了响应。如果是这样，我们可以处理该响应并等待其他请求完成。

你可以看到这种方法如何减少执行时间，因为我们更加有效地利用了等待时间。
  
现在的问题是：PHP如何允许我们发送请求但不等待？实际上，有一组函数可以做到这一点。在PHP 8.1之前，这些函数通常与yield结合使用，允许程序在执行某些I/O操作时继续执行。如果你想进一步了解这些函数，可以查阅stream_set_blocking和stream_select的文档。

解释纤程的话，没有必要完全理解这些函数的工作原理，重要的是要知道PHP中有一些函数可以以非阻塞的方式工作。例如，发送一个HTTP请求，但在继续执行自己的PHP代码之前不等待它发送响应。

纤程是PHP 8.1中的一种新机制，可以更高效地管理这些并行执行路径。我之前提到使用生成器和yield已经可以实现这一点，但纤程是一个重大改进，因为它们专门为这种用例设计。

从高层次的角度来看，它是这样工作的：

为每个请求创建一个纤程，并在发送请求后暂停纤程。  
请记住，请求本身仍然由外部服务器发送和处理，我们只是一开始不等待响应。
![[Pasted image 20231118072936.png]]
  
你看，纤程是一种机制，用于启动、暂停和恢复程序中一个隔离部分的执行流程，使您能够轻松管理异步I/O。纤程也被称为“绿色线程”：实际上在同一个进程中运行的线程。这些线程不是由操作系统管理，而是由运行时（在我们的情况下是PHP运行时）管理。本质上，它们是一种成本效益高的管理某些形式的并行编程的方式。

但请注意，它们并没有添加任何真正的异步功能：所有的纤程都存在于同一个PHP进程中，一次只能运行一个。它是主进程循环遍历它们并在等待时检查它们，这个循环通常被称为“事件循环”。
  
随着PHP 8.1中引入纤程，Amphp和ReactPHP联手创建了一个基于纤程的新事件循环实现。该项目被称为"Revolt PHP"，似乎是PHP世界中两个最重要的异步参与者之间的一次富有成效的合作。
  
然而，并行性的困难并不在于如何循环遍历纤程、生成器或任何你想使用的机制；而是在于能够启动一个操作，将其交给外部服务，并在你想要的时候以非阻塞的方式检查结果。
  
在之前的例子中，我们假设我们可以随时发送请求并在需要时检查其响应，但实际上并没有这么简单。事实上，大多数PHP的I/O函数并没有内置这种非阻塞功能。只有少数几个函数具备这种功能，并且使用它们相当麻烦。例如，套接字就是一个例子，可以设置为非阻塞模式，如下所示：
![[Pasted image 20231118073115.png]]
  
通过使用stream_socket_pair()，创建了两个可用于双向通信的套接字。正如您所看到的，可以使用stream_set_blocking()将其设置为非阻塞。还有一些其他支持此功能的函数。  
假设我们想要实现我们的例子，发送三个请求。我们可以使用套接字来实现，但是我们需要自己在其上实现HTTP协议。我不认为你想在应用代码中处理这个问题吧？  
所以，相反地，有一些异步PHP框架来处理所有幕后的事情。像Amp或ReactPHP这样的框架。让我们以ReactPHP为例；使用它，我们可以编写如下代码：![[Pasted image 20231118073222.png]]
  
这是一个比手动创建套接字连接更好的例子。
  
这就引出了一个问题：与我们已经可以通过生成器做的事情相比，纤程的好处是什么？RFC这样解释：
  
与无栈生成器不同，每个Fiber都有自己的调用栈，使得它们可以在深度嵌套的函数调用中暂停。一个声明了  中断点（即调用Fiber=:suspend()）无需更改其返回类型，而使用yield的函数必须返回一个Generator实例。  
Fibers可以在任何函数调用中暂停，包括从PHP VM内部调用的函数，例如提供给array_map的函数或由foreach在Iterator对象上调用的方法。

  
声明一个函数很明显，纤程在语法和灵活性方面都是一个重大改进。
  
然而，要使异步PHP成为主流而不需要框架的开销，仍然缺少很多功能。纤程是朝着正确方向迈出的一步，但我们还没有达到目标。
  
