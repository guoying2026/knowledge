  
  在本书的前面，我们谈到了类型系统及其对编程语言的价值。我们还谈到了PHP类型系统的最新变化，以及通过添加适当的差异支持使其更加灵活。编程语言中的类型安全是一个非常有趣的话题，我决定在本章中专门讨论它。

当我们谈论静态分析时，我展示了一个RgbValue类的示例，用于表示“0到255之间的整数值”。这种类型确保了有效的输入，并允许我们去除冗余的输入验证。它看起来像这样：
![[Pasted image 20231118070941.png]]
  
使用RgbValue作为类型，我们保证只会传递给我们的函数符合其描述的子集的输入。这里有一个有趣的词，即子集。所有类型都可以被视为对所有可用输入的过滤器。RgbValue表示正整数的子集，它又是所有整数的子集，而所有整数又是所有标量值（整数、浮点数、字符串等）的子集，而标量值又是所有值的子集。

它们是一切的子集。你能看到某种继承链形成的心理形象吗？
  
RgbValue > 正整数 > 所有整数 > 标量值 > 一切。
  
这是另一个例子：当我们谈论PHP的类型系统时，我们有一个叫做UnknownDate的类；它代表了一个缺失的日期，并允许我们使用空对象模式。UnknownDate是Date的子类型，而Date又是object的子类型，而object又是一切的子类型。

  
该接口表示发票类型，并且它有一个规则：它有一个付款日期。该接口承诺，任何实现发票的对象都会返回 在调用getPaymentDate()时返回一个有效的日期对象。那么，对于PendingInvoice呢？我们决定让它返回一个UnknownDate。这引发了一个问题：Invoice接口所做的承诺是否仍然有效？
![[Pasted image 20231118071138.png]]
  
当然可以！由于所有未知日期都是日期的子集，这意味着无论何时返回一个未知日期，我们总是可以确定它也是一个日期。这就是方差。
![[Pasted image 20231118071116.png]]
描述：在继承过程中发生变化的类型定义，仍然满足父类的原始承诺。在返回类型的情况下，我们允许在继承过程中进一步指定它们，这被称为“协变”。在参数类型的情况下，情况恰恰相反。

很难找到一个有意义的反变类型的例子 -  
与协变类型相反。它们在PHP中很少使用：它们与泛型结合使用时最有意义，而PHP不支持泛型。

  
尽管如此，还是有一些边缘情况下反变可能会有用。让我们考虑一个例子：

Repository接口描述了一个简化的仓库：一个可以从数据存储中检索和存储对象的类。该仓库假设所有的ID都是整数。
![[Pasted image 20231118071325.png]]
    
还有一个WithUuid接口，它允许传递文本UUID而不是数字。接下来让我们实现OrderRepository类：

  ![[Pasted image 20231118071640.png]]
这里存在一个问题：我们不能在retrieve方法中使用int $id，因为这违反了WithUuid指定的契约。如果我们使用string $uuid，问题将会反过来。

这些边缘情况使逆变类型变得有用：PHP允许我们扩大参数类型，以履行Repository和WithUuid所做的承诺。由于PHP 8.0的联合类型，我们可以这样编写retrieve的实现：
![[Pasted image 20231118071618.png]]
  
这段代码有效！当然，现在我们需要手动处理在retrieve方法中的字符串和整数的管理；不过，当问题无法避免时，有这个选项还是很好的。

  
返回类型是协变的，参数类型是逆变的。那么有关类型化属性呢？它们是不变的，这意味着在继承过程中不允许更改属性类型。在类型化属性的RFC中清楚地解释了这一点：“属性类型是不变的原因是它们既可以读取又可以写入。从int到?int的变化意味着从属性读取的值现在可能返回null，而不仅仅是整数。从?int到int的变化意味着不再可以将null写入属性。因此，逆变和协变都不适用于属性类型。”

在PHP 7.4之前，即使在技术上是正确的，也不允许扩大或缩小类型。虽然这似乎是一个小的改变，但实际上它使PHP的类型系统更加灵活易用。



