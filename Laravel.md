laravel的生命周期
1、laravel请求的入口是public/index.php文件。这个文件首先加载composer生成的自动加载器。

2、创建一个laravel服务容器，服务容器是laravel中用于管理类依赖和进行依赖注入的工具。

3、引导阶段
注册引导类，
 3.1首先是加载环境变量，.env文件中的环境变量。这对于配置数据库连接，邮件服务以及其他需要从环境变量中读取设置的服务是必要的。
 3.2 加载位于config目录下的所有配置文件
 3.3 设置了异常处理程序和错误处理函数。
 3.4 注册门面，使用门面代理访问服务容器的底层方法。
 3.5 注册服务提供者。从config/app.php配置文件中，加载注册服务提供者。调用所有服务提供者的register方法，用于绑定服务到容器。注意绑定不是实例化。
 3.6 调用服务提供者的boot方法。进行初始化
 3.7还有延迟服务提供者，只有在真正需要的时候才会加载。
4、然后选择内核。http请求选择http内核，命令行请求选择console内核。
5、然后请求处理包括中间件和路由解析
6、路由分发到控制器。
7、响应通过路由中间件处理，然后返回用户。
8、请求结束。

laravel框架5个核心概念
1、服务容器$app
本质上就是数组，比如有
instance已经实例化好的对象，
bingdings是已经绑定到数组，但没有实例化，key value对应的是抽象类型到构建它们的闭包的映射，
alias是服务别名。
resolved数组会跟踪哪些服务已经被解析。
make是容器解析并实例化具体类的过程，首先会在instance这个实例化好的对象数组isset查找对象，有的话就返回。
如果没有现成的实例instance，

容器会从bindings数组获取绑定的闭包或者构造信息。


然后容器会检查能不能可以解析。如果不能就继续递归执行make.

如果检查可以解析，调用build方法，build里面就是【如果是闭包，就直接执行，】如果不是闭包，就使用php 反射new ReflectionClass获取，分析构造函数并递归解析它的参数。最后使用反射类里newInstanceArgs方法来实例化类。

2、服务提供者
每个类都包含了register方法和boot方法，
register方法用于绑定服务到容器，所以一般来说register里面会执行$this->app->bind(接口类或抽象类，具体实现类)；

而boot方法则在所有服务提供者的register方法被调用后执行，用于执行启动后的配置或服务初始化。

3、门面
它提供了一种静态接口，让访问服务容器中的对象更加方便。

门面使用了静态魔术方法，__callStatic来代理对服务容器中底层类的方法调用。每个门面类都定义了一个getFacadeAccessor方法，方法返回一个字符串，字符串就是一个服务容器绑定的键名或别名。

4、契约
原生php支持类型提示和接口，但没有内置的服务容器来自动解析这些依赖，在没有框架的原生php应用，你需要手动创建所需对象并管理它们的依赖关系。

通过依赖注入契约而不是具体实现。利用php反射在自动解析这些依赖。

5、管理器manager
管理器模式用于创建和管理多种驱动实现，提供统一的api接口。

管理器通常实现了一个driver方法，该方法根据配置动态创建和返回具体的驱动实例。

6、管道
设计模式：责任链
描述：管道模式用于构建一系列操作，其中每个操作都有机会处理一个传递给它的请求并返回一个响应。这在laravel的中间件中得到了广泛应用。

7、事件
设计模式：观察者模式
描述：laravel允许模型类使用观察者模式来监听模型创建、更新、删除等事件。有助于在不修改模型类本身的情况下，对模型的生命周期事件进行监听和响应。

8、查询构建器
设计模式：建造者
描述：laravel的查询构建器允许使用流畅的接口来构建sql查询，而无需手动编写sql语句。

9、



历史
![[Pasted image 20231118101224.png]]
![[Pasted image 20231118101252.png]]
