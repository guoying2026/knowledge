PHP拥有丰富的扩展生态系统，其中大部分可以通过简单的pecl install ...命令进行安装。许多扩展通过与第三方库集成来提供其功能。以imagick为例，它是用C语言编写的，并将底层的ImageMagick库作为PHP的函数暴露出来。imagick扩展本身并不提供图像处理功能，它只是在PHP和ImageMagick之间提供了一个桥梁。

FFI（完整的英文全称为"foreign function interface"）使得暴露这些底层库的过程变得"更容易"。我用引号是因为你仍然需要了解这些库在底层是如何工作的，但你不再需要编写和分发一个专门的扩展了。FFI之所以使这个过程更容易，是因为它允许你在原本需要用C语言实现扩展的地方，使用PHP来编写。

换句话说：如果所需的库存在于您的服务器或本地开发环境中，您可以通过使用composer和仅下载PHP代码来安装类似扩展的功能。只要它能编译成共享库，您就可以与任何语言集成，Unix和Linux系统上是.so文件，Windows上是.dll文件。

感受下FFI代码的样子，你需要将头文件定义加载到$ffi变量中，并使用该变量中的结构体和函数。此外，您不能只复制此代码片段并通过Web请求运行它：由于安全原因，FFI仅在CLI和预加载脚本中默认启用。想象一下，如果您能够通过Web请求操纵FFI代码，并获得访问所有系统二进制文件并潜在利用其中的安全漏洞的权限。请注意：您可以在Web请求中启用FFI，但在这样做之前，您应该三思而后行。最后，您需要启用opcache才能使FFI正常工作，因此，如果您通过CLI运行此脚本，您将需要专门启用opcache，因为默认情况下它是禁用的。

![[Pasted image 20231118065311.png]]
  
头文件记录了你正在集成的共享库中可用的功能。这在C编程中很常见，但在PHP中却不常见。

一个头文件是结构体和函数的定义列表，没有它们的实际实现；类似于类的接口。不幸的是，PHP的FFI不支持所有现代头文件的语法。因此，虽然原始的头文件可用于您想要集成的任何库，但很可能您需要专门为PHP重新编写它们以便理解。

正如你所看到的，FFI编程不仅仅是编写简单的PHP代码。另一方面，尽管FFI的性能不如编译的C扩展——因为需要解析头文件的开销——但与直接在PHP中实现相同功能相比，它可以提供显著的性能改进。总结一下：FFI有潜力，但不是即插即用的解决方案。

这就引出了一个问题：FFI有哪些使用场景？首先想到的是那些在低级别中更高效完成的CPU密集型任务。

像C或Rust这样的语言比PHP更适合使用FFI。所以我在社区里询问了谁在使用FFI，确实有一些人在使用。一个例子是高效解析大型数据集。还有一种用例是使用composer来发布类似扩展的代码。

另一个有趣的例子是改变PHP运行时本身，这样你就不需要在PHP文件中添加开头的。

  
有一个有趣的GitHub存储库，列出了使用PHP中的FFI的示例，名为gabrielrcouto/awesome-php-ffi。

尽管如此，大多数FFI项目仍然非常年轻。FFI从PHP 7.4开始支持，所以在这本书发布时只有一年的历史。总体而言，FFI还没有被广泛使用。这并没有什么问题：它是一个相当小众的解决方案，不是很多PHP开发人员需要处理的。不过，FFI有潜力，但可能需要一些改进才能被广泛采用。所以让我们期待它在未来几年中的发展吧！

