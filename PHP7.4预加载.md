1、在PHP 7.4中添加。这是一个可以显著提高代码性能的功能，通过在服务器启动时将缓存的PHP文件加载到内存中。预加载是通过使用专用的预加载脚本来完成的 - 您必须自己编写或生成该脚本。该脚本在服务器启动时执行一次，从该脚本中加载的所有PHP文件将在所有后续请求中都可用于内存中。

2、预加载本身是建立在opcache之上的，但并不完全相同。Opcache会在运行时将您的PHP源文件编译为"opcodes"，并将这些编译文件存储在磁盘上。您可以将opcodes视为代码的低级表示，可以在运行时轻松解释。下次请求缓存文件时，可以跳过翻译步骤，直接从磁盘读取文件。在实践中，像这样的简单PHP指令：echo 1+2;

echo 1+2;会被翻译成这样的操作码；

![[Pasted image 20231118034317.png]]

  Opcache已经显著加快了PHP的速度，但还有更多的收益。最重要的是：opcached文件不知道其他文件。如果你有一个类Order继承自一个类Model，PHP仍然需要在运行时将它们链接在一起。

所以这就是预加载发挥作用的地方：它不仅会将源文件编译为操作码，还会将相关的类、特性和接口链接在一起。然后它将保持这个“已编译”的可运行代码块 - 也就是：PHP解释器可用的代码 - 存储在内存中。当一个请求到达服务器时，它现在可以使用已经加载到内存中的代码库的部分，而没有任何额外的开销。

预加载比opcache更能提高性能，因为它已经链接了文件，不需要从磁盘读取缓存的操作码，并且不需要处理缓存的失效。一旦文件被缓存，它将一直存在，直到服务器重新启动。

为了使预加载起作用，你作为开发者需要告诉服务器要加载哪些文件。这可以通过一个简单的PHP脚本来实现，该脚本可以包含其他文件。规则很简单：

1、提供一个预加载脚本，并在php.ini文件中使用以下方式链接：opcache.preload
2、每个你想要预加载的PHP文件都应该在脚本中加载。你可以使用opcache_complie_file()或require_once来实现。

规则很简单，假如你想要预加载laravel框架。你的脚本将需要循环遍历vendor/laravel目录中的所有php文件，并逐个包含它们。

![[Pasted image 20231118062608.png]]

警告：无法预加载未链接的类

请稍等，这里有个警告！要预加载文件，它们的依赖关系-接口，特征和父类-也必须预加载。如果类的依赖有任何问题，服务器启动时会通知您。

这是之前讨论的部分，预加载文件的依赖项也必须被加载；否则php无法预加载它们，顺便说一下，这不是致命错误-你的服务器将正常启动-但它表明你想要的预加载的并非所有文件都能够成功预加载。

幸运的是，有一种方法可以确保加载php文件所有的依赖项，不使用opcache_compile_file,而是使用require_once，并让注册的自动加载器，并让注册的自动加载器（composer）来处理其余部分。

![[Pasted image 20231118063311.png]]
仍然有一些注意事项。例如，如果你尝试预加载laravel，框架内的某些依赖于尚不存在的其他类。
例如，文件系统缓存类\Illuminate\Filesystem\Cache依赖于\League\Flysystem\Cached\Storage\AbstractCache，如果您从未使用文件系统缓存，则可能未在项目中安装该类。

尝试预加载所有内容时，可能会遇到“类未找到”的错误。唯一的解决方案是跳过这些文件的预加载。幸运的是，在默认的Laravel安装中，只有少数这些类，可以轻松忽略它们。为了方便起见。写了一个小的预加载器类。
![[Pasted image 20231118063710.png]]
![[Pasted image 20231118063730.png]]
![[Pasted image 20231118063750.png]]
![[Pasted image 20231118063805.png]]
![[Pasted image 20231118063902.png]]
![[Pasted image 20231118063917.png]]
![[Pasted image 20231118063930.png]]
通过在相同的预加载脚本中添加这个类，我们现在可以这样加载整个laravel框架。
![[Pasted image 20231118064039.png]]
![[Pasted image 20231118064055.png]]
  
所以请记住，每次您对预加载脚本或其预加载文件进行更改时，都需要重新启动服务器。我并不是指物理上重新启动整个服务器，只需重新启动php-fpm即可。如果您使用的是Linux机器，只需运行sudo service php8.0-fpm restart即可。将8.0替换为您所使用的版本。

有了所有这些预加载的文件，我们确定它们是否被正确加载了吗？你可以通过重新启动服务器并在一个PHP脚本中转储opcache_get_status()的输出来简单测试。你会看到一个名为preload_statistics的键，它将列出所有预加载的函数、类和脚本，以及预加载文件所消耗的内存。

还有一件在使用预加载时需要提及的重要事情。你已经知道需要在php.ini中指定一个条目才能使预加载工作。如果你使用的是共享主机，你将无法自由地配置PHP。实际上，你需要一个专用（虚拟）服务器才能优化单个项目的预加载文件。所以请记住这一点。

关于最重要的问题：预加载是否能提高性能？好吧，我们来进行基准测试！就像使用JIT一样，我将进行实际基准测试，测量相对结果并测量一个真实项目。了解在你自己的项目中，预加载是否值得花费时间，而不仅仅是在理论基准测试中。这个项目它将再次进行一些数据库调用、视图渲染等操作。

由于我对预加载对我的代码的相对影响最感兴趣，所以我决定在我的本地机器上使用Apache Bench运行这些基准测试。我将发送5000个请求，每次同时发送50个请求。Web服务器是Nginx，使用PHP-FPM。

早期版本的预加载存在一些错误，所以我只能在PHP 7.4.2及更高版本上成功运行这些基准测试。

我将对三种情况进行基准测试：一种是禁用预加载，一种是将所有Laravel和应用程序代码预加载，一种是使用优化的预加载类列表。后一种情况的理由是预加载也会带来内存开销。如果我们只预加载“热门”类-即经常使用的类-我们可能能够在性能提升和内存使用之间找到一个平衡点。

预加载已禁用
![[Pasted image 20231118064405.png]]

这是结果：我们能够每秒处理64.79个请求，每个请求的平均时间为771毫秒。这是我们的基准情景，我们可以将下一个结果与此进行比较。

接下来，我们将预加载所有的Laravel和应用程序代码。这是一种天真的方法，因为我们在一个请求中从未使用过所有的Laravel类。我们预加载了比严格需要的文件更多，所以我们将为此付出代价。在这种情况下，预加载了1165个文件及其依赖项，导致包括1366个函数和1256个类。

如我之前提到的，你可以从opcache_get_status()中读取该信息。

![[Pasted image 20231118064615.png]]

opcache_get_status()提供的另一个指标是预加载脚本所使用的内存。在这种情况下，使用了17.43 MB的内存。尽管我们预加载了比实际需要的代码更多，但是简单的预加载已经对性能产生了积极的影响。

![[Pasted image 20231118064631.png]]
已经可以看到性能提升：我们可以处理更多的请求每秒，并且处理一个请求的平均时间下降了约20%。

最后，我们想要比较使用优化的预加载列表时的性能提升。为了测试目的，我启动了没有启用预加载的服务器，并且转储了在该请求中使用的所有类：
![[Pasted image 20231118064730.png]]
接下来，我只预加载了这些类（总共427个）。加上它们所有的依赖关系，总共预加载了643个类和1034个函数，占用大约11.76 MB的内存。
![[Pasted image 20231118064741.png]]
与不使用预加载相比，性能提升约为25%，与使用朴素方法相比，性能提升约为8%。然而，这种设置存在一个缺陷，因为我为一个特定页面生成了一个优化的预加载列表。实际上，如果您想要覆盖所有页面，可能需要预加载更多的代码。

另一种方法可能是在生产服务器上监视哪些类在几个小时或几天内加载了多少次，并根据这些指标编译一个预加载列表。一个可以实现这个功能的包叫做darkghosthunter/preloader。绝对值得一试。

可以肯定地说，预加载——即使使用天真的“预加载一切”的方法——对于基于完整框架构建的实际项目也有积极的性能影响。

此外，在基于完整框架构建的实际项目中也是如此。然而，还有一个重要的附注需要提醒。实际应用程序很可能不会出现25%的性能增加。这是因为它们做的事情远不止启动一个框架。一个重要的事情是I/O：与数据库服务器通信，读写文件系统，与第三方服务集成等等。因此，虽然预加载可以优化代码的启动部分，但仍可能存在其他对性能影响更大的领域。到底能获得多少收益将取决于您的代码、服务器和使用的框架。我建议你去尝试一下，并不要忘记测量结果。



