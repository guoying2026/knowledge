事件溯源、CQRS、事件驱动；如果你以前从未在事件驱动系统中工作过，这些神秘的术语可能会让人望而生畏。即使你有经验，也会有很多观点、理论和模式。总体而言，它可能看起来非常复杂。
  
事件驱动系统并不是解决所有问题的方法。虽然它们增加了一层灵活性，但也减少了简单性和明确性。

从本质上讲，事件驱动开发并不是那么困难。更困难、但也更强大的是基于简单概念构建的模式。这种力量通常在复杂和大型应用程序中需要，而事实上：PHP经常用于构建这样的应用程序。我想在这个主题上专门写一章，因为你在职业生涯中可能需要处理某种形式的事件驱动系统。拥有一些背景信息是很重要的。

所以让我们从基础知识开始。
  
事件驱动系统的思想是，你不再微观管理程序流程，而是允许各个组件在发生事件时做出反应。例如：不是有一个单一的函数或服务来管理“创建发票”的过程，而是可以有几个小型服务，每个服务处理发票创建过程的一部分。起点是创建发票；接下来有一个生成PDF并将其保存在文件系统上的服务；还有一个向客户发送电子邮件，通知他们有一张待付款的发票。

我在一个段落中使用了三个术语来描述“当发生某些事情时会触发的一段代码”。你甚至可以考虑将它们称为“微服务”。暂时我们不会关注这些服务之间如何进行通信的技术细节，并假设它们实际上是同一代码库中的简单对象，在同一台服务器上运行；从现在开始，我将称它们为“服务”。
  
顺便问一下，你有没有注意到Alan Kay对于“对象”的定义完美地契合了这个模型？我喜欢当事情能够完美结合在一起的感觉！
  
这些服务不一定需要彼此了解：它们在系统中发生事件时做出反应。这个“事件”被称为“事件”。

从技术角度来看，事件驱动系统所需的只是一个事件总线：它是一个中央位置，知道所有监听事件的服务；我们也可以称它们为“事件订阅者”。每当发生事件时，事件总线会被通知，然后通知所有相关的订阅者。编写一个简单的事件总线并不难。例如，以下是一个只有几行代码的实现：
![[Pasted image 20231118073742.png]]
![[Pasted image 20231118073815.png]]
  
你可以想出很多细节和补充，但在其核心，这就是你所需要的：一个订阅者列表，可以在事件被派发时通知他们。
  
没有什么能阻止你将这样的事件总线设置为异步。事实上，在进行异步编程时，事件驱动的系统通常是首选：它是一个非常适合并行和异步思维方式的模型。
  
对于我们的示例，我们假设事件总线始终同步处理事件：这样更容易理解事件流，并消除我们必须处理的许多技术细节。

在我们的发票示例中，我们有两个订阅InvoiceCreatedEvent事件的服务：
InvoicePdfService类实现Subscriber接口：
public function handles(object $event): bool
return $event instanceof InvoiceCreatedEvent;
![[Pasted image 20231118074040.png]]
![[Pasted image 20231118074113.png]]
  
尽管如此，我们的实现还需要一些改进。通过向我们的事件总线添加一些反射能力，我们可以根据方法签名确定订阅者是否应该处理事件。这不仅使我们的代码更简洁，还允许我们在订阅者中准确地知道我们正在处理的事件类型。让我们想象一下，我们已经重构了我们的事件总线，现在可以这样编写订阅者：

![[Pasted image 20231118074201.png]]

让我们继续深入探索我们的事件驱动系统。它有一个重要的限制 - 实际上，这是所有事件驱动系统的主要特点：间接性。

  
想象一下，在发票创建后触发发票创建事件：

![[Pasted image 20231118074329.png]]
  
虽然事件驱动开发承诺了灵活性 - 你可以连接任意多的订阅者 - 但它也导致了一种间接耦合的形式。当我们触发这个事件时，我们不知道会发生什么具体的事情；我们需要相信正确的订阅者会在我们看不见的情况下处理它。这种间接性的层次会使得调试程序流程变得更加困难，即使事件是同步处理的。除此之外：在分发事件之后，你不能有任何直接的返回值，因为无限数量的订阅者可以处理该事件。然而，你可以引入一些轮询层来观察结果，比如一个数据库。

  
尽管如此，你仍然需要处理许多复杂情况：灵活性是以简单性为代价的。
  
你有没有注意到我们还没有编写任何“事件溯源”或“CQRS”代码，但我们已经在使用事件驱动的程序了？在最简单的形式下，你不需要事件溯源、命令总线、CQRS或微服务。你只需要事件。
  
足够的时间过去后，任何在这样的事件驱动系统中工作的开发者都会遇到这种简化方法的问题。
  
可能会出现各种性能问题：开发体验下降、扩展问题或管理一致性和状态的问题。您自然会尝试通过应用模式和原则来解决这些问题，这正是  事件驱动的社区多年来一直在做的事情。他们提出了一些模式来帮助解决更困难的问题，这些问题在现实生活中的复杂系统中会遇到。

Martin Fowler写了几篇关于这些模式以及社区是如何发现它们的文章，并进行了讲解。在本章的下一部分，我将简要讨论其中四个经常使用的模式。相关链接将列在本章的末尾。

  
1、事件通知
  
最简单的事件驱动系统形式被称为“事件通知”：事件仅用于通知已发生的事情。我们的例子中的InvoiceCreatedEvent已经比这更复杂，因为我们使用了请求数据并将其与事件一起发送。

通过事件通知，事件只表示某事发生了。由服务自己去访问数据库、第三方服务或外部状态，并确定他们想要使用的数据。这也是最弱的事件驱动开发形式：一切仍然紧密耦合在一起。唯一的区别是你利用事件的灵活性将多个服务连接到一个事件上。

2、事件传递状态转移
  
第二种模式是我们在示例中应用的：当事件发生时，我们捕获相关数据并将其与事件一起发送。处理该事件的所有服务只允许使用由该事件封装的数据。
  
这种方法确保我们可以有多个服务监听同一个事件，并且不必担心它们的处理顺序。我们始终确信我们的服务不会依赖外部状态，因此事件成为了“真相的来源”。

3、事件溯源    
基于事件携带所有必要状态的想法，产生了事件溯源。

例如，不是将发票保存到数据库中，而是保存事件本身，这样会有什么好处呢？
  
如果事件成为真相的来源并保存到数据库中，我们随时都可以获得额外的信息层。现在，我们不仅知道最终结果是什么（发票），还知道构成该结果的步骤是什么（事件）。
  
请看这个事件列表，也称为“事件流”：
![[Pasted image 20231118074855.png]]
  
如果我们只使用事件来触发服务执行某些操作，那么在处理完事件后，我们将丢失事件的数据。传统应用程序经常处理这些问题，这就是为什么它们在数据库中跟踪状态变化的原因：在发票上添加类似created_at或payment_date的列，并且必须从那里仔细管理。

如果我们直接保存事件，我们可以从存储中检索它们（数据库、文件系统或其他方式），并从头开始动态重建应用程序状态。例如，我们可以重建这些事件所产生的发票 - 至少只要这些存储的事件携带了所有相关数据。

这就是事件溯源的威力：只需使用事件就能重建整个应用程序状态。它为有趣的用例打开了大门。例如，我们可以基于这些事件中可用的历史数据开始生成报告。我们可以生成一份分析客户在发票发送后支付所需的平均时间的报告，而无需重写我们的数据模型。没错：我们需要的所有数据已经存储为事件，我们只需要以一种新的方式解释它们。
  
随着事件溯源的引入，也带来了许多其他问题。其中最紧迫的问题是性能。一个生产应用程序会随着时间的推移存储数以百万计的事件；当请求到来时，我们肯定不能每次都从头开始重建整个应用程序状态。这就是为什么有其他模式来帮助我们解决这些问题：投影和快照经常被用来构建一个缓存和可重用的状态，而不是总是从头开始重建它。一个实际的例子可能是一个发票投影：一个存储所有这些发票事件的最终结果并且我们可以轻松读取数据的表。
  
另一个常与事件溯源相关的抽象概念是改变的意图和改变本身之间的区别。当我们直接触发一个InvoiceCreatedEvent时，感觉有点不对：发票本身还没有被创建。相反，更合理的做法是将意图称为CreateInvoice，将实际结果存储在数据库中的称为InvoiceCreated。第一个通常被称为"命令"，而第二个被称为"事件"。

尝试正确应用事件溯源时会出现很多复杂性。这是因为我们最基本的实现也增加了复杂性的相同原因：这是我们为了更灵活和可扩展的系统所付出的代价。请记住这一点：  
牢记：事件驱动架构并不总是解决问题的正确方案。更简单的方法可能不仅更快，而且更好。

  
一位聪明的开发者Frank De Jonge曾经说过：“事件溯源使简单问题变得困难，而困难问题变得简单”。在将事件溯源添加到项目之前，请确保权衡利弊。

  
4、CQRS - 命令查询责任分离 - 是第四个也是最后一个模式

我想谈谈这个。马丁·福勒这样描述它：“其核心是这样的概念，即您可以使用不同的模型来更新信息，而不是用于阅读的模型。”
  
信息。对于某些情况，这种分离可能是有价值的[...]理由是对于许多问题，特别是在更复杂的领域中，命令和查询具有相同的概念模型会导致一个更复杂的模型，既不能很好地执行命令，也不能很好地进行查询。
  
换句话说：CQRS的目标是将写入数据和读取数据的关注点分离开来。

它再次提供了更大的灵活性。请记住，这是一个适用于非常复杂系统的模式。Martin Fowler甚至警告不要过快地使用CQRS：“尽管有这些好处，但你在使用CQRS时应该非常谨慎。许多信息系统与信息库的概念非常匹配，即以相同的方式进行更新和读取，将CQRS添加到这样的系统中可能会增加显著的复杂性。”

关于事件驱动系统还有很多要讲的，但超出了本书的范围。几个PHP框架可以实现事件驱动系统，但最重要的是拥有事件驱动的思维方式，而不仅仅是一堆技术工具。我希望你对这种思维方式有一点了解，并且如果你对此感兴趣，我建议你查阅更多相关资源。

