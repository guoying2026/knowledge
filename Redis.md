1. **基本概念**:
    
    - 请解释Redis队列在Laravel中是如何工作的。
        redis队列在laravel中作为一个队列驱动，用于处理异步任务。它存储待处理的任务，并在后台工作进程中逐个执行这些任务。
        
    - 你如何设置和配置Laravel项目以使用Redis队列？
          在laravel中设置redis队列，首先需要在.env文件中将队列链接配置为redis,并确保安装了php redis扩展。
          
1. **队列处理**:
    - 在"现货拼车"业务中，你会如何决定哪些任务应该放入队列处理？
        ![[Pasted image 20231120040128.png]]
    ![[Pasted image 20231120040143.png]]
    
    - 描述一下在Laravel中创建和处理队列任务的步骤。
    - ![[Pasted image 20231120040239.png]]
    - ![[Pasted image 20231120040258.png]]
    - laravel里面使用了Dispatchable trait类，并 实现了ShouldQueue接口。构造函数是用它来把数据放到作业对象中,handle方法这是作业逻辑应该驻留的地方。
    - dispatchable trait类，使其有具有自行调度的方法，
    - Queueable trait类，允许您指定laravel应该如何将此作业推送到队列。
    - InteractsWithQueue trait类，允许每个作业在处理时与队列交互。控制与队列的关系，包括删除或重新排队。
    - 并且SerializesModels trait类，使作业具有能够序列化和反序列化eloquent模型。（转换为可以存储在数据库或队列系统等数据存储中的更平坦的格式）以便作业的handle()方法可以访问它们。然而，由于可靠地序列化整个Eloquent对象太困难，该特性确保只序列化附加的Eloquent对象的主键，当作业被推送到队列时。当作业被反序列化和处理时，该特性通过它们的主键从数据库中获取这些Eloquent模型的最新实例。这意味着当作业运行时，它将获取该模型的最新实例，而不是您将作业排队时的状态。
    - ![[Pasted image 20231120040402.png]]
     ![[Pasted image 20231120040422.png]]
	 laravel将读取类型提示，并自动注入该依赖项将作业推送到队列中。
	 有多种方法可以把job放到队列(每个控制器有个方法或者是全局的dispatch助手函数)，最好的办法是在job本身上调用dispatch。
	![[Pasted image 20231120052654.png]]
	定制链接
	![[Pasted image 20231120052749.png]]
	定制队列
	![[Pasted image 20231120052808.png]]
	定义延迟
	![[Pasted image 20231120052827.png]]
	如果你需要一系列的工作按顺序地一个一个运行。你可以将它们链接在一起，每个作业都等前一个作业运行完，如果一个作业失败，后面的作业将不会运行。
	![[Pasted image 20231120053105.png]]
	当其中一个作业链接失败时，你可以执行catch方法。
	![[Pasted image 20231120053118.png]]
	![[Pasted image 20231120053213.png]]
	作业批处理
	
	作业批处理使得可以同时将一组作业推送到队列中，检查批处理的状态，并在批处理完成后执行操作
	此功能需要一个数据库表来跟踪作业；
    正如您所预期的那样，有一个Artisan命令来创建它：![[Pasted image 20231120073242.png]]
    要将作业标记为可批处理，请包含 Illuminate\Bus\Batchable trait。此 trait 会为您的作业添加一个 batch() 方法，该方法允许您检索有关当前批处理作业的信息。
    您可以看到批处理作业中最重要的一步是确保在批处理被取消时不执行任何操作。
    ![[Pasted image 20231120073547.png]]
    在laravel中调度可批处理的作业
    bus门面提供了一个batch方法，允许派发一批作业，可以使用then成功，catch失败或finally（成功或失败）方法定义在批处理成功或失败后要执行tt行的操作。
    ![[Pasted image 20231120073730.png]]
      
分派可批处理作业 将作业添加到批处理中 从作业中添加作业
  
如果您的批处理作业有添加作业到批处理的责任-例如，如果您最初分派了一些作业，之后想添加
![[Pasted image 20231120074213.png]]
取消批次
![[Pasted image 20231120074232.png]]
![[Pasted image 20231120074326.png]]
默认情况下，如果批处理中的一个作业失败，该批处理将被标记为“取消”。如果您想定义不同的行为，可以在调度批处理时链接allowFailures()
  
批次表不会自动清理，所以您需要安排计划，  
让您的应用程序“清理”该表：
![[Pasted image 20231120074406.png]]
队列工作进程
  
它是一个Artisan命令，会一直运行下去（直到手动停止），并负责从队列中拉取 作业并运行它们：
![[Pasted image 20231120074545.png]]
  
此命令启动一个守护进程，"监听"您的队列；每当队列中有作业时，它将拉取第一个作业，处理它，删除它，然后继续下一个。如果在任何时候  
没有工作，它会“休眠”一段可配置的时间，然后再次检查是否有更多的工作。
  
在队列监听器停止之前定义作业可以运行多少秒，（--timeout）
当没有作业时，听众应该“休眠”的秒数（--sleep），
在被删除之前每个作业允许尝试多少（--tries），
worker进程应该监听哪个连接（queue:work后的第一个参数），以及应该监听哪些队列（--queue=）：
![[Pasted image 20231120074557.png]]

也可以使用php artisan处理单个作业
php artisan queue:work;
如果抛出异常，队列监听器将释放job回到队列里，该job被重新发布，一遍又一遍的处理，直到成功完成或者达到队列监听器允许的最大尝试次数为止

最大尝试次数由 --tries定义。传递给queue:listen或queue:work Artisan命令的开关。

如果你不设置--tries，或者将其设置为0，队列监听器将允许无限次重试。这意味着如果有任何情况下作业无法完成，例如依赖于已被删除的推文，您的应用程序将会因为无限次重试而变得非常缓慢。文档和Laravel Forge都将3作为最大重试次数的推荐起点。因此，如果有困惑的情况，请从那里开始并进行调整：php artisan queue:work --tries=3。如果您想要检查作业已经尝试了多少次，请在作业本身上使用attempts()方法.
![[Pasted image 20231120075750.png]]
![[Pasted image 20231120075811.png]]
  
您还可以通过在作业类本身上定义$tries来指定给定作业可以重试的最大次数
属性。当指定此值时，它将优先于调用php artisan queue:work -- tries=5时设置的值。
尝试次数=5。
  
您可以在作业类中设置$maxExceptions属性，以指定作业可以抛出异常的次数（和  因此应重新尝试）在被视为失败之前：
![[Pasted image 20231120080041.png]]
  
您还可以指定作业的超时时间，指示尝试任意次数的框架来完成工作  指定的时间范围。您可以指定一个retryUntil()方法。  
在一项工作中，并从中返回一个Carbon/DateTime实例。
返回现在时间+30秒
![[Pasted image 20231120080208.png]]
基于work的重试延迟
我们可以指定在重试失败的工作之前等待多长时间，设置作业的$retryAfter属性，等同于等待的分钟数。对于更复杂的计算，我们可以选择其他方法。
![[Pasted image 20231120080221.png]]

job中间件
  
我们可以通过中间件来运行作业，就像我们运行我们的通过中间件进行HTTP请求。这是一个很好的机会。
提取保护或验证您的工作或任务的逻辑，
![[Pasted image 20231120080449.png]]
  
要将中间件分配给作业，请在作业类中指定一个中间件方法：
![[Pasted image 20231120080501.png]]
在调度作业时，您还可以指定中间件
![[Pasted image 20231120080539.png]]

  job的速率限制中间件
![[Pasted image 20231120080620.png]]
处理失败job  
一旦工作超过允许的重试次数，它被视为“失败”工作。在做任何其他操作之前，即使您只想限制工作的重试次数，您需要创建“失败的工作”数据库表。
![[Pasted image 20231120080752.png]]
任何超过允许最大数量的job,尝试将被丢弃在那里，可以对失败的job做什么，您可以在作业本身上定义一个failed()方法，当该作业失败时将运行该方法。
  
接下来，你可以为失败的任务注册一个全局处理程序。
在应用程序的引导过程中——如果你不知道应该放在哪里，就将其放在AppServiceProvider的boot()方法中
![[Pasted image 20231120081024.png]]
![[Pasted image 20231120081131.png]]

![[Pasted image 20231120081148.png]]
![[Pasted image 20231120081213.png]]
![[Pasted image 20231120081238.png]]
![[Pasted image 20231120081252.png]]
  
使用release()将作业重新放回队列中
![[Pasted image 20231120104513.png]]
删除作业
![[Pasted image 20231120104636.png]]
1. **Redis作为队列驱动的优势**:
    - 为什么选择Redis作为队列驱动？它相比其他队列驱动（如数据库、Amazon SQS）有哪些优点？
      ![[Pasted image 20231120041233.png]]
      ![[Pasted image 20231120041258.png]]
      
4. **性能和可靠性**:
    
    - 使用Redis队列时，如何确保任务处理的高可用性和可靠性？
    - 你会如何监控队列的性能和状态？
    - 使用laravel horizon,监控队列的性能和状态。
    - 提供有关redis排队作业状态的洞察，可以看到哪些作业失败了，有多少作业在排队。
    - ![[Pasted image 20231120041327.png]]
5. **错误处理和重试机制**:
    
    - 当队列任务失败时，你会如何处理？
    - 如何设置任务重试的策略？
      ![[Pasted image 20231120043313.png]]
      ![[Pasted image 20231120043345.png]]
      ![[Pasted image 20231120043651.png]]
      ![[Pasted image 20231120043727.png]]
      ![[Pasted image 20231120043801.png]]
      
1. **Redis特有的问题和解决方案**:
    
    - 使用Redis作为队列驱动可能会遇到哪些特有的问题？
    - 如果Redis服务器宕机，你将如何应对？
7. **安全性问题**:
    
    - 在使用Redis队列时，有哪些安全性问题需要考虑？
    - 如何保证队列数据的安全？
8. **最佳实践和经验分享**:
    
    - 在你之前的项目中，使用Redis队列有哪些最佳实践或教训？
    - 你是否有优化Redis队列性能的经验？
