HashMap

1、为什么哈希表能做到o(1)复杂度呢？

哈希表基于数组实现，而数组可以根据下标随机访问任意元素。数组之所以可以任意访问，是因为它由连续内存承载，且每个数组元素的大小都相等。

我们知道下标后，把下标乘以元素大小，再加上数组的首地址，就可以获得目标访问地址，直接获取数据。

其次，哈希函数直接把查询关键字转换为数组下标，再通过数组的随机访问特性获取数据。

如果关键字是字符串，我们使用bkdr哈希算法将其转换为自然数，再以哈希数组大小为除数，对它进行求余，就得到了数组下标。

#不考虑范围查询和遍历操作，追求最快速度使用，哈希表是最快的选择。

WeakHashMap

在php中有点儿类似行为的是php8.0,进一步引入了 `WeakMap` 类。php7.4，引入了弱引用，允许开发者创建对对象的引用，而这些引用不会阻止对象被垃圾回收器回收。`WeakMap` 实例允许对象作为键，而不阻止对象的垃圾回收。一旦对象被销毁，它在 `WeakMap` 中的记录也会自动被移除。
	![[Pasted image 20231117021854.png]]
这个特性使得 `WeakMap` 在某些特定场景下非常有用，比如实现缓存、跟踪对象而不妨碍它们的回收、或者在对象之间建立关联数据而不创建内存泄漏。在内部，`WeakMap` 利用了 PHP 的垃圾回收机制，确保只要没有其他地方引用对象，它就可以被回收，从而允许更有效的内存管理。

具体来讲跟踪对象而不妨碍它们的回收，比如用在 #Laravel 框架中使用的 Monolog 日志库的 `Logger.php` 文件.

![[Pasted image 20231117023400.png]]
![[Pasted image 20231117023610.png]]
![[Pasted image 20231117023440.png]]

### 使用 `WeakMap` 和 `Fiber`

这段代码的一个关键特性是使用了 `WeakMap` 来跟踪在 PHP 8.1 中引入的 `Fiber` 对象的日志深度。`Fiber` 是 PHP 提供的一种新的协程实现，可以实现轻量级的并发。在 `Logger` 类中，`WeakMap` 被用来存储每个 `Fiber` 实例的日志深度，从而防止在处理 `Fiber` 时产生的潜在无限递归日志记录问题。这是 Monolog 为了适应 PHP 新特性而做的一个适配。

IdentityHashMap

EnumMap

ConcurrentHashMap


2、除了哈希表能o(1)之外，位图也可以o（1）

位图本质上是哈希的变种，限制每个哈希桶只有1个比特位，所以，虽然它消耗的空间最小，但仅用于辅助数据的主索引，快速判断对象是否存在。

位图常用于解决 #缓存穿透 的问题，也常用于 #查找数组中的可用对象

![[Pasted image 20231116160602.png]]

位图数组每个元素1比特（0表示不存在，1表示存在），而数据数组每元素大小与对象大小一致，位图数组用于一一对应数据数组，所以它们的元素个数一致，两个数组的同一下标表示相同对象，这样，位图数组表示数据是否存在，如果存在，使用同一下标可以访问数据。

为什么要这么设计呢？遍历位图的速度要远快于数据数组，这因为批量按位比较快，也因为cpu缓存处理位图时，可以预存更多的对象。

3、红黑树的时间复杂度是o(logN),logN随着数据规模的增长，运行时间的增长是急剧放缓的。如果需求中需要做范围查询、遍历。由于哈希表没办法找到关键字相邻的下一个元素，所以哈希表不支持这类操作。